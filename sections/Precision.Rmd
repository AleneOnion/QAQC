---
title: "Precision"
author: "Alene Onion"
date: "December 29, 2018"
output:
  html_document:
    toc: true
    toc_depth: 6
    toc_float: true
---

```{r setupP, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
#file.copy("sections/images", ".", recursive = TRUE)
```

##Precision Assessment  

* Precision   
    + Duplicate samples are analyzed from the same date/location to assess the method's precision.    
    + Previously, the % difference between these samples must satisfy the precision criteria set forth in table 3 (screening) and table 4 (routine). In this document, we propose using a new method developed by Ohio EPA that offers a curved threshold.    

The details of this method are given here: (https://www.epa.ohio.gov/portals/35/documents/sw_samplingmanual.pdf)

In short, they reject any duplicate sample pair where the %RPD > (0.9465x^-0.344)100 +5  
where:
x = sample / detection limit
%RPD = [diff(duplicate pair)/av(duplicate pair)]*100  
NOTE: I used the maximum of the two samples to calculate x  

The precision assessments are performed on a subset of samples. The errors discovered with these QC assessments are applied to all normal samples. This is done by associating normal samples to those QC samples closest in date/time to each sample. 


###plots  
To examin failures visually, I plotted sample/DL versus %RPD as well as the threshold equation described above.  
Any point above the line should be rejected. Any point below the line is accepted. If the line isn't visible, that means it is above the range of the graph and all the points would be accepted.  
NOTE: I only plotted parameters that had at least one failed duplicate sample result.  
```{r, echo=FALSE}
#converting non-detects to 0
dup$result_value.dup <- ifelse(dup$lab_qualifiers.dup=="U",0,dup$result_value.dup)
dup$result_value.dup <- ifelse(dup$lab_qualifiers.dup=="UN",0,dup$result_value.dup)
dup$result_value.dup <- ifelse(dup$lab_qualifiers.dup=="UE",0,dup$result_value.dup)
dup$result_value.parent <- ifelse(dup$lab_qualifiers.parent=="U",0,dup$result_value.parent)
dup$result_value.parent <- ifelse(dup$lab_qualifiers.parent=="UN",0,dup$result_value.parent)
dup$result_value.parent <- ifelse(dup$lab_qualifiers.parent=="UE",0,dup$result_value.parent)
#Calculating RPD
dup$RPD<-((dup$result_value.parent-dup$result_value.dup))
#can't divide by 0 so I calculate the denominator first 
dup$RPD<-ifelse(dup$RPD==0,0,((dup$RPD)/(dup$result_value.parent+dup$result_value.dup/2))*100)
dup$RPD<-abs(dup$RPD)
#remove parameters wihtout method detection limits
dup<-dup[!is.na(dup$method_detection_limit.parent),]
#this step is necessary to make sure you're using the max sample value
dup$ratio<-ifelse(pmax(dup$result_value.parent, dup$result_value.dup)==dup$result_value.parent,
                  ifelse(dup$result_value.parent==0,0,(dup$result_value.parent/dup$method_detection_limit.parent)),
                  ifelse(dup$result_value.dup==0,0,(dup$result_value.dup/dup$method_detection_limit.dup)))
dup$eq<-ifelse(dup$ratio!=0,(100*0.9465*(dup$ratio^-0.344))+5,0)
dup$pass<-ifelse((dup$eq>dup$RPD)|(dup$RPD==0),"pass","fail")
#ohio's line of acceptability
eq = function(x){(0.9465*(x^(-0.344)))*100+5}

params<-dup[dup$pass=="fail",]
params<-params[!is.na(params$pass),]
params<-unique(params$chemical_name)
nparams<-length(params)

if (nparams > 0) {
  for(i in 1:nparams){
  temp<-dup[dup$chemical_name==params[i],]
  #plot the result values
  plot(temp$ratio,temp$RPD,type="p",lwd=4,col="forestgreen",main=params[i],xlab="sample/DL ratio",ylab="RPD")
  abline(h=20)
  lines(eq(1:1000),type="l",lwd=4,col="deepskyblue")
 rm(temp) 
  }
  rm("i")
}
rm(list=c('params','nparams','eq'))
```

###Precision Rejected Samples  
```{r, echo=FALSE,warning=FALSE}
#truncate the dup file
dups<-unique(dup[c('chemical_name','pass','sample_date.parent')])
names(dups)[names(dups)=='sample_date.parent']<-'sample_date'
dups$sample_date<-as.Date(dups$sample_date,"%m/%d/%Y")

samples<-unique(data[c('sys_sample_code','chemical_name','sample_date')])
samples$sample_date<-as.Date(samples$sample_date,"%m/%d/%Y")

params<-unique(dups$chemical_name)
nparams<-length(params)

for(i in 1:nparams){
  temp<-samples[samples$chemical_name==params[i],]
  tempd<-dups[dups$chemical_name==params[i],]
  tempd$sample_date<-as.Date(tempd$sample_date,"%m/%d/%Y")
  sites<-unique(temp$sys_sample_code)
  nsites<-length(sites)
  for(j in 1:nsites){
    temp1<-temp[temp$sys_sample_code==sites[j],]
    temp1$sample_date<-as.Date(temp1$sample_date,"%m/%d/%Y")
    tempd1<-tempd[which(abs(tempd$sample_date-temp1$sample_date)==min(abs(tempd$sample_date-temp1$sample_date))),]
    temp1$pass<-tempd1$pass[1]
    if(exists("dataset")){
      dataset<-merge(dataset,temp1,all=TRUE)
    }
    if(!exists("dataset")){
      dataset<-temp1
    }
    rm(list=c('temp1','tempd1'))
  }
  rm(list=c('temp','tempd','sites','nsites','j'))
}
rm(list=c('params','nparams','i','samples','dups'))

#rename pass to duppass
names(dataset)[names(dataset)=='pass']<-'duppass'
#merge with final data dataset
#first convert data date to a date
data$sample_date<-as.Date(data$sample_date,"%m/%d/%Y")
data<-merge(data,dataset,by=c('sys_sample_code','chemical_name','sample_date'),all=TRUE)
data<-data[!is.na(data$chemical_name),]
rm(dataset)
```

```{r message=FALSE, warning=FALSE, results='asis'}
#plotting the sample failures
#count fails and passes
library(plyr)
dupfails<-count(dup[c('short','pass')])
samplefails<-count(data[c('short','duppass')])
names(samplefails)[names(samplefails)=='duppass']<-'legend'
names(dupfails)[names(dupfails)=='pass']<-'legend'

library(ggplot2)
library(ggpubr)
theme_set(theme_pubr())

 samplefails<-(ggplot() +
    geom_col(data=samplefails,aes(short,freq,fill=legend)) +
      coord_flip() +
      theme(axis.title.x = element_blank(),axis.title.y = element_blank()))
 dupfails<-(ggplot() +
    geom_col(data=dupfails,aes(short,freq,fill=legend)) +
      coord_flip() +
      theme(axis.title.x = element_blank(),axis.title.y = element_blank()))
 print(ggarrange(
  samplefails, dupfails, labels = c("associated sample fails", "individual dup fails"),
  common.legend = TRUE, legend = "bottom"
  ))
 rm(list=c('dupfails','samplefails'))
 rm(dup)
```

```{r message=FALSE, warning=FALSE, results='asis'}
#This bit of script converts pass faill to R (reject) and A (Accept)
data$duppass<-gsub("pass","A",data$duppass)
data$duppass<-gsub("fail","R",data$duppass)

```


